+++
title = "[WIP]Day 12 完成实验Lab1"
date = 2025-09-26
description = "2025操作系统训练营记录 完成实验Lab1"
[taxonomies]
categories = ["操作系统", "Rust", "学习记录"]
tags = ["2025 秋冬季开源操作系统训练营", "Rust", "操作系统", "学习计划", "Lab1"]
+++

{{ banner(src="oscamp_header.png", alt="2025 秋冬季开源操作系统训练营 Day 12", caption="Day 12") }}

# 功能实现

## trace_request=0
将 `id` 视为内存地址，使用 `*` 解引用读取 1 字节。

## trace_request=1
将 `id` 视为内存地址，使用 `write_volatile` 写入 1 字节。

## trace_request=2
统计当前任务的系统调用次数。

`task` 即 `TaskControlBlock`。在其中维护字段 `syscall_times: [SyscallCounter; SYSCALL_COUNT]` 记录各 `syscall` 的调用次数。

由于当前没有提供哈希结构，采用定长数组，通过索引与 `syscall` 编号建立映射。整体流程：

1. 获取当前 `task`
2. 在 `syscall_times` 中定位对应编号的计数器并执行 `+1`

### syscall 与索引映射部分
为了避免硬编码，实现思路：

提供一个 `SyscallCounter` 查找匹配的能力。

- **如果不存在和 `syscall_id` 一样的元素**：匹配到第一个 `syscall_id` 是 0 的 `SyscallCounter` 元素，并且把 `syscall_id` 赋值为当前调用的 `syscall_id`，执行 +1 操作。

- **如果存在和 `syscall_id` 一样的元素**：执行 +1 操作。

# 问答题

## 1. 用户态程序特征测试
正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。请同学们可以自行测试这些内容（运行三个 bad 测例 `ch2b_bad_*.rs`），描述程序出错行为，同时注意注明你使用的 sbi 及其版本。

答：

sbi及其版本
```bash

[rustsbi] RustSBI version 0.3.0-alpha.2, adapting to RISC-V SBI v1.0.0
.______       __    __      _______.___________.  _______..______   __
|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |
|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |
|      /     |  |  |  |    \   \       |  |      \   \    |   _  < |  |
|  |\  \----.|  `--'  |.----)   |      |  |  .----)   |   |  |_)  ||  |
| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|
[rustsbi] Implementation     : RustSBI-QEMU Version 0.2.0-alpha.2
```

`ch2b_bad_register`



## 2. 深入理解 trap.S 中两个函数的作用
深入理解 `trap.S` 中两个函数 `__alltraps` 和 `__restore` 的作用，并回答如下问题：

### 2.1 L40 问题
刚进入 `__restore` 时，`sp` 代表了什么值。请指出 `__restore` 的两种使用情景。

### 2.2 L43-L48 寄存器处理
这几行汇编代码特殊处理了哪些寄存器？这些寄存器的值对于进入用户态有何意义？请分别解释。

```asm
ld t0, 32*8(sp)
ld t1, 33*8(sp)
ld t2, 2*8(sp)
csrw sstatus, t0
csrw sepc, t1
csrw sscratch, t2
```

### 2.3 L50-L56 跳过寄存器
为何跳过了 `x2` 和 `x4`？

```asm
ld x1, 1*8(sp)
ld x3, 3*8(sp)
.set n, 5
.rept 27
    LOAD_GP %n
    .set n, n+1
.endr
```

### 2.4 L60 指令意义
该指令之后，`sp` 和 `sscratch` 中的值分别有什么意义？

```asm
csrrw sp, sscratch, sp
```

### 2.5 状态切换
`__restore` 中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？

### 2.6 L13 指令意义
该指令之后，`sp` 和 `sscratch` 中的值分别有什么意义？

```asm
csrrw sp, sscratch, sp
```

### 2.7 U 态到 S 态切换
从 U 态进入 S 态是哪一条指令发生的？

# 荣誉准则

## 1. 交流记录
在完成本次实验的过程（含此前学习的过程）中，我曾分别与以下各位就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

> 暂无

## 2. 参考资料
此外，我也参考了以下资料，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

> 暂无

## 3. 独立完成声明
我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

## 4. 代码使用声明
我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按"-100"分计。
