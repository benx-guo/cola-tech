+++
title = "Day 12 完成实验Lab3"
date = 2025-09-26
description = "2025操作系统训练营记录 完成实验Lab3"
[taxonomies]
categories = ["操作系统", "Rust", "学习记录"]
tags = ["2025 秋冬季开源操作系统训练营", "Rust", "操作系统", "学习计划", "Lab3"]
+++

{{ banner(src="oscamp_header.png", alt="2025 秋冬季开源操作系统训练营 Day 12", caption="Day 12") }}

# 功能实现

## 如果 trace_request 为 0，则 id 应被视作 *const u8 ，表示读取当前任务 id 地址处一个字节的无符号整数值。此时应忽略 data 参数。返回值为 id 地址处的值

将 `id` 视为内存地址，使用 `*` 解引用读取 1 字节。

## 如果 trace_request 为 1，则 id 应被视作 *mut u8 ，表示写入 data （作为 u8，即只考虑最低位的一个字节）到该用户程序 id 地址处。返回值应为0。

将 `id` 视为内存地址，使用 `write_volatile` 写入 1 字节。

## 如果 trace_request 为 2，表示查询当前任务调用编号为 id 的系统调用的次数，返回值为这个调用次数。本次调用也计入统计 。

统计当前任务的系统调用次数。

`task` 即 `TaskControlBlock`。在其中维护字段 `syscall_times: [SyscallCounter; SYSCALL_COUNT]` 记录各 `syscall` 的调用次数。

由于当前没有提供哈希结构，采用定长数组，通过索引与 `syscall` 编号建立映射。整体流程：

- 获取当前 `task`
- 在 `syscall_times` 中定位对应编号的计数器并执行 `+1`

### syscall 与索引映射部分

为了避免硬编码，实现思路：

提供一个 `SyscallCounter` 查找匹配的能力。

- **如果不存在和 `syscall_id` 一样的元素**：匹配到第一个 `syscall_id` 是 0 的 `SyscallCounter` 元素，并且把 `syscall_id` 赋值为当前调用的 `syscall_id`，执行 +1 操作。

- **如果存在和 `syscall_id` 一样的元素**：执行 +1 操作。

# 问答题

## 1. 用户态程序特征测试

**问题：** 正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。请同学们可以自行测试这些内容（运行三个 bad 测例 `ch2b_bad_*.rs`），描述程序出错行为，同时注意注明你使用的 sbi 及其版本。

**回答：**

**使用的 SBI 及其版本：**

```bash

[rustsbi] RustSBI version 0.3.0-alpha.2, adapting to RISC-V SBI v1.0.0
.______       __    __      _______.___________.  _______..______   __
|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |
|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |
|      /     |  |  |  |    \   \       |  |      \   \    |   _  < |  |
|  |\  \----.|  `--'  |.----)   |      |  |  .----)   |   |  |_)  ||  |
| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|
[rustsbi] Implementation     : RustSBI-QEMU Version 0.2.0-alpha.2
```

**测试 `ch2b_bad_register` 的错误行为：**

用户态程序无法访问 S 态特权寄存器（如 `sstatus`），同样会触发 `IllegalInstruction` 异常。

**测试 `ch2b_bad_instructions` 的错误行为：**

用户态程序无法执行 S 态特权指令（如 `sret`），会触发 `IllegalInstruction` 异常。

**测试 `ch2b_bad_address` 的错误行为：**

用户态程序无法访问无效地址，会触发 `PageFault` 异常。

## 2. 深入理解 trap.S 中两个函数的作用

**问题：** 深入理解 `trap.S` 中两个函数 `__alltraps` 和 `__restore` 的作用，并回答如下问题：

### 2.1 L40 问题

**问题：** 刚进入 `__restore` 时，`sp` 代表了什么值。请指出 `__restore` 的两种使用情景。

**回答：**

- `sp` 指向内核栈
- 两种使用情景：
  1. 从内核态返回用户态
  2. 从 switch 任务进入用户态

### 2.2 L43-L48 寄存器处理

**问题：** 这几行汇编代码特殊处理了哪些寄存器？这些寄存器的值对于进入用户态有何意义？请分别解释。

```asm
ld t0, 32*8(sp)
ld t1, 33*8(sp)
ld t2, 2*8(sp)
csrw sstatus, t0
csrw sepc, t1
csrw sscratch, t2
```

**回答：**

- **sstatus**: 设置用户模式，确保 `sret` 指令返回用户态
- **sepc**: 中断/异常时的 PC 或者任务切换时，用户程序的入口地址，确保 `sret` 指令跳转到用户程序地址
- **sscratch**: 用户栈 SP

### 2.3 L50-L56 跳过寄存器

**问题：** 为何跳过了 `x2` 和 `x4`？

```asm
ld x1, 1*8(sp)
ld x3, 3*8(sp)
.set n, 5
.rept 27
    LOAD_GP %n
    .set n, n+1
.endr
```

**回答：**

- **x2**: 当前指向内核栈，如果在恢复其他寄存器之前，恢复 x2 的话，后续都会基于用户栈
- **x4**: 应用程序不使用

### 2.4 L60 指令意义

**问题：** 该指令之后，`sp` 和 `sscratch` 中的值分别有什么意义？

```asm
csrrw sp, sscratch, sp
```

**回答：**

- `sp` 指向用户栈
- `sscratch` 指向内核栈

### 2.5 状态切换

**问题：** `__restore` 中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？

**回答：**

`sret` 指令。

- 特权切换到用户态
- PC 跳到 `sepc` 指向的地方
- SP 已经指向用户栈

### 2.6 L13 指令意义

**问题：** 该指令之后，`sp` 和 `sscratch` 中的值分别有什么意义？

```asm
csrrw sp, sscratch, sp
```

**回答：**

- `sp` 指向用户栈
- `sscratch` 指向内核栈

### 2.7 U 态到 S 态切换

**问题：** 从 U 态进入 S 态是哪一条指令发生的？

**回答：**

`ecall` 指令。

# 荣誉准则

## 1. 交流记录
在完成本次实验的过程（含此前学习的过程）中，我曾分别与以下各位就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

> 暂无

## 2. 参考资料
此外，我也参考了以下资料，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

> 暂无

## 3. 独立完成声明
我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

## 4. 代码使用声明
我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按"-100"分计。
