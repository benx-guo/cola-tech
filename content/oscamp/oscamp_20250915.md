+++
title = "Day 1 rustlings 100/110"
date = 2025-09-15
description = "2025操作系统训练营记录 rustlings 100/110"
[taxonomies]
categories = ["操作系统", "Rust", "学习记录"]
tags = ["2025 秋冬季开源操作系统训练营", "Rust", "操作系统", "Rustling"]
+++

{{ banner(src="oscamp_header.png", alt="2025 秋冬季开源操作系统训练营 Day 1", caption="Day 1") }}

## 今日目标

- [x] 完成100项 rustlings 任务

## 学习总结

通过今天的 rustlings 练习，深入理解了 Rust 的核心概念：内存管理、所有权系统和堆栈机制。这些基础概念是后续学习操作系统内核开发的重要基石。

## 重点内容回顾

### 内存布局

{{ concept_image(src="stack_heap.png", alt="栈内存布局示意图", caption="图1：进程内存布局示意图 - 栈向下生长，堆向上生长") }}

典型进程内存布局：低地址处是代码段与只读数据，其后是已初始化/未初始化数据段；中间为堆（向高地址增长）与映射区（mmap）；高地址处为栈（向低地址增长）。这种设计使堆与栈相向生长，便于按需扩展，最大化利用虚拟地址空间。

### 栈（Stack）

{{ concept_image(src="method_stack.png", alt="栈示意图", caption="图2：方法调用栈变化示意图") }}

栈遵循后进先出（LIFO）原则。函数调用时压入返回地址、参数和局部变量，栈指针随之向低地址移动；返回时栈帧整体弹出，指针复位，内存自动回收。适合编译期大小固定的数据，如基本类型、引用等。

```rust

fn example() {
    let x = 5;        // 局部变量 x 入栈
    let y = 5;       // 局部变量 y 入栈
    // 函数结束时，x 和 y 自动出栈
}
```

### 堆（Heap）

{{ concept_image(src="heap.png", alt="堆内存布局示意图", caption="图3：堆内存分配示意图") }}

堆用于运行期大小不确定或需跨栈帧存活的数据，如`String`、`Vec`。分配/释放有开销，访问经指针间接完成；在Rust中，离开作用域由所有权自动释放，避免了内存泄漏。

```rust

fn heap_example() {
    let mut s1 = String::from("hello"); // 在堆上分配内存
    s1 = format!("{} world", "hello");
    // String 的所有权在 s1 上，当 s1 离开作用域时自动释放堆内存
}
```

## Rust所有权系统

{{ concept_image(src="ownership.png", alt="Rust所有权示意图", caption="图4：Rust所有权机制示意图") }}

所有权是Rust内存安全的核心机制，确保无需垃圾回收也能安全管理内存：每个值有且只有一个所有者，离开作用域自动释放；配套机制包括移动、拷贝与借用。

```rust

fn main() {
    // 移动（move）：所有权转移
    let s1 = String::from("hi");
    let s2 = s1;              // s1 被移动，之后不能再用 s1
    // println!("{}", s1);   // 编译错误

    // 拷贝（copy）：栈上小型标量类型实现 Copy，可按位拷贝
    let a: i32 = 10;
    let b = a;                // a 仍然可用

    // 借用（&T）：只读访问，不获取所有权
    let len = len_ref(&s2);

    // 可变借用（&mut T）：独占可写，作用域内不能同时存在其他借用
    let mut s3 = String::from("hello");
    push_ref(&mut s3);

    // 获取所有权
    takes_ownership(s2);  // s2 被移动，之后不可用
    // println!("{}", s2); // 编译错误：s2 已被移动
}

fn len_ref(s: &String) -> usize {
    s.len()
}

fn push_ref(s: &mut String) {
    s.push('!');
}

fn takes_ownership(s: String) {
    println!("Took ownership of: {}", s);
}

```

## 小结

今天把栈与堆的区别、进程内存布局，以及所有权/借用的基本回顾一下。